# 217.contains-duplicate.md

![](https://dl.dropboxusercontent.com/scl/fi/wpu7mk6gl4jol4hfivqhx/Code_hp1lsXepGJ.png?rlkey=g4162uquw28bofotvw38n1yqy&dl=0)

// cool solution using Set object.
// Set only keeps unique values, so if there are duplicates,
// the size of the Set will be less than the length of the original array.

```return new Set(nums).size !== nums.length;```

- Create new set object
- Put the nums array inside the Set(...) object and check the size.
    - Now the Set object will only check length of unique objects.
- Efficiently checks if !== nums.length. 
- If both lists are equal, return true.
- If lengths are unequal, return false. nums.length is longer or null.


## AI explanation
I'll explain the selected line and give a couple quick notes and alternatives.

Checklist
- Explain what `return new Set(nums).size !== nums.length;` does — Done  
- Explain why it detects duplicates and its complexity — Done  
- Note edge cases and a small alternative (early-exit) — Done

What the line does
- `new Set(nums)` builds a Set containing the unique elements of `nums`.
- `.size` is the number of unique elements.
- `nums.length` is the total number of elements in the array.
- Comparing them with `!==` returns true when the counts differ — i.e., when there are fewer unique items than array items, so at least one duplicate exists.
- So the function returns true if the array contains any duplicate, false otherwise.

Why this is correct
- A Set only keeps one copy of each value; if any value appears more than once in `nums`, the Set size will be strictly less than the array length, so the inequality holds.
- For numbers this is reliable; JS Set treats NaN as equal to NaN and +0 and -0 as equal, so those edge cases behave sensibly for duplicate detection.

Complexity
- Time: O(n) to iterate `nums` and build the Set.
- Space: O(n) worst-case to store unique elements.

Notes and alternatives
- This approach always constructs a Set for the whole array. If you expect duplicates often and want to exit early, use an explicit loop with a Set and return true as soon as you see an already-seen value:
  - for (const x of nums) { if (seen.has(x)) return true; seen.add(x); } return false;
- Sorting is another alternative (O(n log n) time, O(1) extra space if in-place) but usually slower.
- For non-primitive elements (objects/arrays), duplicate detection compares references, not deep equality.

If you want, I can replace the one-liner with the early-exit loop to save time/memory when duplicates typically occur early.